# Global ARG — must be before the first FROM for --build-arg to work
ARG BASE_IMAGE

# -------------------------------------------------------------------
# Stage 1: Build libnsm.so from source (NSM device interaction)
# -------------------------------------------------------------------
FROM rust:1.85-slim AS nsm

RUN apt-get update && apt-get install -y git && rm -rf /var/lib/apt/lists/*

# Pin to v0.4.0 commit SHA for supply chain integrity
ENV AWS_NE_NSM_API_SHA="5798fec36f49e1d199c77947f4e51f86b663750f"
RUN git clone https://github.com/aws/aws-nitro-enclaves-nsm-api.git && \
    cd aws-nitro-enclaves-nsm-api && \
    git checkout ${AWS_NE_NSM_API_SHA} && \
    cargo build --release -p nsm-lib

# -------------------------------------------------------------------
# Stage 2: Build the application (uses pre-built base with deps)
# -------------------------------------------------------------------
ARG BASE_IMAGE
FROM ${BASE_IMAGE} AS builder

WORKDIR /app

# Copy source code (deps already installed in base image)
COPY . .

# Create symlinks for workspace module resolution
RUN ln -sf /app/node_modules /app/packages/sdk/node_modules && \
    ln -sf /app/node_modules /app/packages/server/node_modules

# -------------------------------------------------------------------
# Stage 3: Runtime — Nitro Enclave
# -------------------------------------------------------------------
FROM oven/bun:1.3-debian

# Install socat for vsock bridging, curl for health checks, iproute2 for lo setup
RUN apt-get update && apt-get install -y socat curl iproute2 net-tools && rm -rf /var/lib/apt/lists/*

# Create non-root user (entrypoint drops privileges after network setup)
RUN useradd --create-home --shell /bin/bash appuser

# Copy libnsm.so built from aws-nitro-enclaves-nsm-api
COPY --from=nsm /aws-nitro-enclaves-nsm-api/target/release/libnsm.so /usr/lib/libnsm.so
RUN ldconfig

# Copy the built application from the builder stage
COPY --from=builder /app /app
RUN chown -R appuser:appuser /app
WORKDIR /app/packages/server

# Nitro Enclaves communicate via vsock, not TCP.
# socat bridges vsock port 5000 → localhost:4000 (Express server).
ENV PORT=4000
ENV TEE_MODE=nitro

# Entrypoint: start the Express server, then bridge vsock → TCP
COPY <<'ENTRYPOINT' /entrypoint.sh
#!/bin/bash
# Send startup messages to serial console (readable via `nitro-cli console` in debug mode).
exec > /dev/console 2>&1
set -e

echo "=== TEE-Rex Enclave Starting ==="

# Bring up loopback WITH IP address (Nitro Enclave doesn't do this by default).
# CRITICAL: `ip link set lo up` alone only brings the link up but does NOT assign
# 127.0.0.1, so localhost connections fail. `ifconfig lo 127.0.0.1` does both.
ifconfig lo 127.0.0.1 2>/dev/null || {
  ip link set lo up
  ip addr add 127.0.0.1/8 dev lo
} 2>/dev/null || true

# WORKDIR not preserved by enclave init
cd /app/packages/server

# The server and socat write to /dev/null instead of /dev/console.
# In non-debug mode, nobody reads from the serial port so the kernel's
# tty buffer (~4KB) fills from log output and write() blocks, deadlocking
# the Bun event loop. In debug mode, `nitro-cli console` drains the buffer
# so blocking doesn't occur — but we redirect to /dev/null unconditionally
# for safety. Debug mode still captures the startup messages above.

# Drop privileges: run server as non-root appuser
su appuser -s /bin/bash -c "bun run src/index.ts" > /dev/null 2>&1 &
SERVER_PID=$!

# Wait for server to be ready
for i in $(seq 1 30); do
  if curl -sf http://localhost:${PORT}/attestation > /dev/null 2>&1; then
    echo "Server ready (attempt $i)"
    break
  fi
  echo "Waiting... attempt $i"
  sleep 1
done

# Bridge vsock port 5000 to TCP port 4000.
# Runs as root because /dev/vsock requires root access inside the enclave.
# socat only proxies bytes — no privilege escalation risk.
socat VSOCK-LISTEN:5000,fork,reuseaddr TCP:localhost:${PORT} > /dev/null 2>&1 &
SOCAT_PID=$!

echo "Enclave ready: TEE_MODE=${TEE_MODE}, vsock:5000 -> tcp:${PORT}"

# Stop writing to console — all startup messages are done.
# This prevents the entrypoint's wait from blocking on console writes.
exec > /dev/null 2>&1

wait $SERVER_PID $SOCAT_PID
ENTRYPOINT

RUN chmod +x /entrypoint.sh

CMD ["/entrypoint.sh"]
