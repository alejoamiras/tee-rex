name: _Deploy Unified (reusable)

on:
  workflow_call:
    inputs:
      ref:
        description: Git ref to checkout
        required: false
        type: string
        default: ""
      environment:
        description: Deployment environment (ci, prod, or devnet)
        required: false
        type: string
        default: "ci"
      nitro_image_tag:
        description: Docker image tag for the nitro/TEE image
        required: false
        type: string
        default: "nightly"
      prover_image_tag:
        description: Docker image tag for the prover image
        required: false
        type: string
        default: "prover"
      base_tag:
        description: "ECR image tag for base image (e.g. base-5.0.0-nightly.20260220)"
        required: true
        type: string
    outputs:
      deployed:
        description: Whether both services were deployed successfully
        value: ${{ jobs.deploy.outputs.deployed }}
      instance_id:
        description: EC2 instance ID used for deployment (masked)
        value: ${{ jobs.deploy.outputs.instance_id }}

jobs:
  # ── Build both Docker images in parallel ──────────────────────────
  build-nitro:
    name: Build Nitro Image
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref || github.ref }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push nitro image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile.nitro
          push: true
          tags: ${{ secrets.ECR_REGISTRY }}/tee-rex:${{ inputs.nitro_image_tag }}
          build-args: BASE_IMAGE=${{ secrets.ECR_REGISTRY }}/tee-rex:${{ inputs.base_tag }}
          cache-from: type=registry,ref=${{ secrets.ECR_REGISTRY }}/tee-rex:cache-nitro
          cache-to: type=registry,ref=${{ secrets.ECR_REGISTRY }}/tee-rex:cache-nitro,mode=max

  build-prover:
    name: Build Prover Image
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref || github.ref }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push prover image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          push: true
          tags: ${{ secrets.ECR_REGISTRY }}/tee-rex:${{ inputs.prover_image_tag }}
          build-args: BASE_IMAGE=${{ secrets.ECR_REGISTRY }}/tee-rex:${{ inputs.base_tag }}
          cache-from: type=registry,ref=${{ secrets.ECR_REGISTRY }}/tee-rex:cache-prover
          cache-to: type=registry,ref=${{ secrets.ECR_REGISTRY }}/tee-rex:cache-prover,mode=max

  # ── Deploy both services to a single EC2 instance ─────────────────
  deploy:
    name: Deploy Unified
    needs: [build-nitro, build-prover]
    runs-on: ubuntu-latest
    timeout-minutes: 25
    permissions:
      id-token: write
      contents: read
    outputs:
      deployed: ${{ steps.health.outputs.deployed }}
      instance_id: ${{ steps.set-instance-id.outputs.instance_id }}
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      INSTANCE_ID: ${{ inputs.environment == 'prod' && secrets.PROD_TEE_INSTANCE_ID || inputs.environment == 'devnet' && secrets.DEVNET_TEE_INSTANCE_ID || secrets.TEE_INSTANCE_ID }}
      ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref || github.ref }}

      # ── Validate required secrets ────────────────────────────────
      - name: Validate secrets
        run: |
          missing=()
          [[ -z "$INSTANCE_ID" ]] && missing+=("INSTANCE_ID (from *_TEE_INSTANCE_ID)")
          [[ -z "$ECR_REGISTRY" ]] && missing+=("ECR_REGISTRY")
          [[ -z "${{ secrets.AWS_ROLE_ARN }}" ]] && missing+=("AWS_ROLE_ARN")
          [[ -z "${{ secrets.AWS_REGION }}" ]] && missing+=("AWS_REGION")
          if [[ ${#missing[@]} -gt 0 ]]; then
            echo "::error::Missing required secrets: ${missing[*]}"
            exit 1
          fi

      - name: Set instance ID output
        id: set-instance-id
        run: echo "instance_id=$INSTANCE_ID" >> "$GITHUB_OUTPUT"

      # ── AWS Credentials via OIDC ─────────────────────────────────
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      # ── Start EC2 Instance ───────────────────────────────────────
      - name: Start EC2 instance
        run: |
          echo "Starting instance ${INSTANCE_ID}..."
          aws ec2 start-instances --instance-ids "${INSTANCE_ID}"

          echo "Waiting for instance to be running..."
          aws ec2 wait instance-running --instance-ids "${INSTANCE_ID}"
          echo "Instance running"

          # Wait for SSM agent to come online (up to 10 min)
          echo "Waiting for SSM agent..."
          for i in $(seq 1 60); do
            STATUS=$(aws ssm describe-instance-information \
              --filters "Key=InstanceIds,Values=${INSTANCE_ID}" \
              --query 'InstanceInformationList[0].PingStatus' \
              --output text 2>/dev/null || echo "None")
            if [ "$STATUS" = "Online" ]; then
              echo "SSM agent online (attempt $i)"
              break
            fi
            if [ "$i" = "60" ]; then
              echo "SSM agent not online after 10 minutes"
              aws ec2 describe-instances --instance-ids "${INSTANCE_ID}" \
                --query 'Reservations[0].Instances[0].{State:State.Name,Launch:LaunchTime}' || true
              exit 1
            fi
            sleep 10
          done

      # ── Deploy via SSM ───────────────────────────────────────────
      - name: Deploy enclave + prover
        run: |
          NITRO_IMAGE_URI="${ECR_REGISTRY}/tee-rex:${{ inputs.nitro_image_tag }}"
          PROVER_IMAGE_URI="${ECR_REGISTRY}/tee-rex:${{ inputs.prover_image_tag }}"

          # Upload ci-deploy-unified.sh via base64 to avoid SSM escaping issues
          SCRIPT_B64=$(base64 -w0 infra/ci-deploy-unified.sh)

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --timeout-seconds 900 \
            --parameters "commands=[
              \"echo '${SCRIPT_B64}' | base64 -d > /tmp/ci-deploy-unified.sh\",
              \"chmod +x /tmp/ci-deploy-unified.sh\",
              \"/tmp/ci-deploy-unified.sh ${NITRO_IMAGE_URI} ${PROVER_IMAGE_URI}\"
            ]" \
            --query 'Command.CommandId' \
            --output text)

          echo "SSM Command: ${COMMAND_ID}"
          echo "Waiting for unified deployment..."

          for i in $(seq 1 120); do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "${COMMAND_ID}" \
              --instance-id "${INSTANCE_ID}" \
              --query 'Status' \
              --output text 2>/dev/null || echo "Pending")

            case "${STATUS}" in
              Success)
                echo "Unified deploy succeeded"
                aws ssm get-command-invocation \
                  --command-id "${COMMAND_ID}" \
                  --instance-id "${INSTANCE_ID}" \
                  --query 'StandardOutputContent' \
                  --output text | tail -20
                break
                ;;
              Failed|TimedOut|Cancelled)
                echo "Unified deployment ${STATUS}"
                echo "=== stdout ==="
                aws ssm get-command-invocation \
                  --command-id "${COMMAND_ID}" \
                  --instance-id "${INSTANCE_ID}" \
                  --query 'StandardOutputContent' \
                  --output text | tail -30
                echo "=== stderr ==="
                aws ssm get-command-invocation \
                  --command-id "${COMMAND_ID}" \
                  --instance-id "${INSTANCE_ID}" \
                  --query 'StandardErrorContent' \
                  --output text | tail -30
                exit 1
                ;;
              *)
                if [ "$i" = "120" ]; then
                  echo "Timed out waiting for SSM command (10 min)"
                  exit 1
                fi
                sleep 5
                ;;
            esac
          done

      # ── Health Check via SSM Tunnels ─────────────────────────────
      - name: Health check
        id: health
        run: |
          curl -sL "https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_64bit/session-manager-plugin.deb" \
            -o /tmp/session-manager-plugin.deb
          sudo dpkg -i /tmp/session-manager-plugin.deb

          # Tunnel to enclave (port 4000 → local 4001)
          aws ssm start-session \
            --target "${INSTANCE_ID}" \
            --document-name AWS-StartPortForwardingSession \
            --parameters '{"portNumber":["4000"],"localPortNumber":["4001"]}' &
          TEE_TUNNEL_PID=$!

          # Tunnel to prover (port 80 → local 4002)
          aws ssm start-session \
            --target "${INSTANCE_ID}" \
            --document-name AWS-StartPortForwardingSession \
            --parameters '{"portNumber":["80"],"localPortNumber":["4002"]}' &
          PROVER_TUNNEL_PID=$!

          trap 'kill $TEE_TUNNEL_PID $PROVER_TUNNEL_PID 2>/dev/null' EXIT

          # Check enclave health
          echo "Checking enclave health..."
          for i in $(seq 1 90); do
            if curl -sf --max-time 5 http://localhost:4001/attestation > /dev/null 2>&1; then
              echo "Enclave healthy (attempt $i)"
              curl -s http://localhost:4001/attestation | jq '{mode, hasDoc: (.attestationDocument != null)}'
              break
            fi
            if [ "$i" = "90" ]; then
              echo "Enclave health check failed after 3 minutes"
              echo "deployed=false" >> "$GITHUB_OUTPUT"
              exit 1
            fi
            sleep 2
          done

          # Check prover health
          echo "Checking prover health..."
          for i in $(seq 1 90); do
            if curl -sf --max-time 5 http://localhost:4002/attestation > /dev/null 2>&1; then
              echo "Prover healthy (attempt $i)"
              curl -s http://localhost:4002/attestation | jq '{mode}'
              echo "deployed=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            if [ "$i" = "90" ]; then
              echo "Prover health check failed after 3 minutes"
              echo "deployed=false" >> "$GITHUB_OUTPUT"
              exit 1
            fi
            sleep 2
          done
